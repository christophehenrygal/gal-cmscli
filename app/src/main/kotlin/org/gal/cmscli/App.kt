/*
 * This source file was generated by the Gradle 'init' task
 */
package org.gal.cmscli

import org.gal.cmscli.dsl.ItemType
import org.gal.cmscli.dsl.dependsOnBean
import org.gal.cmscli.dsl.filteringBean
import org.gal.cmscli.finder.*
import java.io.File

private const val ITEM_TYPES_CLOSING_TAG = "</itemtypes>"
private const val BEANS_TYPE_CLOSING_TAG = "</beans>"

fun main() {
    val itemTypes = generateComponents().also { it.generateJaloClass() }
    val componentFile = findSmartEditComponentsFile()
    val beanFile = findSmartEditBeansFile()
    val deLabelsFile = findSmartEditDeLabelsFile()
    val frLabelsFile = findSmartEditFrLabelsFile()
    val itLabelsFile = findSmartEditItLabelsFile()
    val enLabelsFile = findSmartEditEnLabelsFile()
    // TODO: enhance performances using RandomAccessFile to avoid rewriting all files
    componentFile?.also { generateAndWriteItemsTypesToSmartEditXml(it, itemTypes) }
    beanFile?.also { generateAndWriteBeansToSmartEdit(it, itemTypes) }
    deLabelsFile?.also { generateAndWriteLabelsToSmartEdit(it, itemTypes) }
    frLabelsFile?.also { generateAndWriteLabelsToSmartEdit(it, itemTypes) }
    itLabelsFile?.also { generateAndWriteLabelsToSmartEdit(it, itemTypes) }
    enLabelsFile?.also { generateAndWriteLabelsToSmartEdit(it, itemTypes) }
}

private fun List<ItemType>.generateJaloClass() {
    forEach { it.jaloclass = "net.netconomy.gal.smartedit.jalo.${it.code}" }
}

private fun generateAndWriteItemsTypesToSmartEditXml(
    componentFile: File,
    itemTypes: List<ItemType>,
) {
    val oldContent = componentFile.readText()
    val xmlToAppend = itemTypes
        .map(ItemType::toXml)
        .joinToString(System.lineSeparator())
    val newContent = oldContent.replace(
        ITEM_TYPES_CLOSING_TAG,
        "$xmlToAppend${System.lineSeparator()}$ITEM_TYPES_CLOSING_TAG"
    )
    componentFile.writeText(newContent)
    println("New components are generated in ${componentFile.absolutePath}")
}

private fun generateAndWriteBeansToSmartEdit(beanFile: File, itemTypes: List<ItemType>) {
    val oldContent = beanFile.readText()
    val orderedBeanXmlToAppend = generateOrderedBeans(itemTypes)
    val mandatoryAttributeBeansXmlToAppend = generateMandatoryAttributeBeans(itemTypes)
    val newContent = oldContent.replace(
        BEANS_TYPE_CLOSING_TAG,
        "$orderedBeanXmlToAppend${System.lineSeparator()}$mandatoryAttributeBeansXmlToAppend${System.lineSeparator()}$BEANS_TYPE_CLOSING_TAG"
    )
    beanFile.writeText(newContent)
    println("New beans are generated in ${beanFile.absolutePath}")
}

private fun generateMandatoryAttributeBeans(itemTypes: List<ItemType>): String {
    return itemTypes.map {
        it.attributes.getAttribute()
            .filter { attribute -> attribute.getModifiers().optional.not() }
            .map { attribute -> // No need to use Jackson for this simple XML template
            """
            <bean class="de.hybris.platform.cmsfacades.types.service.impl.DefaultComponentTypeAttributeStructure" p:typecode="${it.code}" p:qualifier="${attribute.qualifier}">
                <property name="populators">
                    <set>
                        <ref bean="requiredComponentTypeAttributePopulator" />
                    </set>
                </property>
            </bean>
            """.trimIndent()
        }.joinToString(System.lineSeparator())
    }.joinToString(System.lineSeparator())
}

// TODO: Check if can be simplified with template like for mandatory beans
private fun generateOrderedBeans(itemTypes: List<ItemType>): String {
    return itemTypes.filter { it.isOrdered }
        .map {
            val customAttributeFilterName = "custom${it.code}AttributeFilter"
            filteringBean {
                id = customAttributeFilterName
                constrainedByProperty {
                    bean {
                        typeCode = it.code
                    }
                }
                property {
                    name = "order"
                    list {
                        it.attributes.getAttribute().forEach {
                            value(it.qualifier)
                        }
                    }
                }
            }.toXml()
                .plus(System.lineSeparator())
                .plus(System.lineSeparator())
                .plus(
                    dependsOnBean {
                        property {
                            ref = customAttributeFilterName
                        }
                    }.toXml()
                )
        }.joinToString(System.lineSeparator())
}

fun generateAndWriteLabelsToSmartEdit(labelsFile: File, itemTypes: List<ItemType>) {
    itemTypes.forEach {
        val componentLabel = "type.${it.code}.name=TODO"
        val keys = it.attributes.getAttribute().map { attribute ->
            "type.${it.code}.${attribute.qualifier}.name=TODO"
        }
        labelsFile.appendText("$componentLabel${System.lineSeparator()}")
        labelsFile.appendText(keys.joinToString(System.lineSeparator()).plus(System.lineSeparator()))
    }
    println("New labels are generated in ${labelsFile.absolutePath}")
}
